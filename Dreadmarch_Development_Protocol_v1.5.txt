Dreadmarch Development Protocol v1.5
====================================

0. Core Governance Rules
------------------------

0.1 No Guessing, No Invention, No Implicit Actions  
All operations must use only information explicitly provided by the user or already present in canonical files.  
If any data is missing, ambiguous, contradictory, or outdated, the AI must stop immediately and request clarification.

0.2 No Parallel Systems / No Duplicate Logic  
No feature, function, structure, dataset, or UI element may have more than one implementation.  
If an operation risks creating duplication, the AI must stop and ask for user direction.

0.3 Interrupt & Environment Reset Awareness  
If the working context resets (tool environment loss, file context loss, memory reset), the AI must immediately notify the user what data is missing and request a reload of all required files.

0.4 Mandatory Rule-Check Before Every Action (Red-Tier Rule)  
Before performing ANY action, the AI must:
- Identify the action category (editor change, dataset change, UI change, modularization step, protocol update, etc.)
- Evaluate the action against ALL relevant protocol rules (Sections 0–8)
- State whether the action is ALLOWED, CONDITIONALLY ALLOWED, or NOT ALLOWED
- Explain why, citing relevant rule sections
- Pause for user confirmation before executing, unless the user has just explicitly requested the action in the previous turn.

If any conflict is found → STOP IMMEDIATELY.

0.5 Simplicity & Simplification Check  
Whenever the AI encounters code, structures, or workflows that appear more complex than necessary, it must:
- Stop and explicitly consider whether a simpler design would serve the same purpose.
- Ask the user whether they want to explore a simpler alternative.
- Clearly describe trade-offs between the current design and the simpler option (flexibility, safety, extensibility, and risk).

No simplification may be applied implicitly. All simplification must be explicitly requested or approved by the user.

1. Dataset Rules
----------------

1.1 All DB5 dataset mutations must occur through strict editor jobs and DB5 patch logic.  
1.2 No recalculation of endpoints, routes, or structure unless explicitly requested.  
1.3 Never infer missing system or route data.  
1.4 Never introduce new schema fields without a formal protocol addition and explicit user approval.  
1.5 Patching within the viewer may create candidate DB5 files, but only the user can promote those to canonical versions.

2. Viewer Architecture Rules
----------------------------

2.1 Single Source of Truth  
The viewer’s dataset, styling, panel registry, and state must remain centralized and canonical.  
All modules must attach to the shared DM4 namespace:

    window.DM4 = window.DM4 || {};

2.2 Boot Process Must Not Fail Silently  
Any missing module, missing dataset, or invalid panel contract must hard-stop initialization with a clear console error and, when possible, a safe no-op destroy() stub.

2.3 Host Integration Separation  
Host wiring (DM4_DATASETS, DM4_startViewerWithDataset, etc.) must stay in host/bootstrap code (index.html and host shims), not inside core modules.

3. UI & Style Contract Rules
----------------------------

3.1 Text Roles  
Only approved text-role classes may be used. No ad-hoc text styles may be introduced in panels or map layers.  
If a new text role is needed, it must be added to the palette/structure CSS and this protocol.

3.2 Palette Variables  
No modification of palette variables may occur outside style modules (CSS or style-profile configuration).  
Inline styles must not hard-code colors that bypass the palette.

3.3 Layout & Frame Integrity  
Structural layout (top bar, sidebars, map frame, control bar) must be controlled through designated layout modules or the viewer core, not ad-hoc DOM mutations in random panels.

4. Editor & Mutation Rules
--------------------------

4.1 All mutations must use the strict DB5 patch system.  
No direct edits to DB5 structures are allowed outside the patcher functions.

4.2 Editor must validate DB5 structure before applying patches.  
Missing systems, sector mismatches, or unsupported op types must cause a hard error and abort the patch, leaving the dataset unchanged.

4.3 Exported patched datasets require explicit user promotion to canonical DB5.  
The viewer may export DB5_Main_Patched_*.json and similar, but canonical filenames and DM4_DATASETS wiring are user-controlled.

4.4 Editor Feature Parity  
Whenever new system-level properties or operations are added (tags, labels, metadata, routes), corresponding editor support must be planned and, when reasonable, wired in from the start.

5. Modularization & Structure Rules
-----------------------------------

5.1 Required Modules (Current Generation)

- dm4-state.js           → State manager (createStateManager, mode, selection, editor jobs, campaign scaffold)
- dm4-panels-editor.js   → EditorPanel and DB5 strict patch processor
- dm4-map-layers.js      → System markers, labels, routes, and data-bounds camera
- dm4-panels-registry.js → Canonical panel configuration and panel registry factory
- dreadmarch-viewer4.js  → Viewer core bootstrap, layout wiring, host integration

Additional modules may be added (identity panels, command/strategic panels, UI shell), but each must have a narrow, clearly defined responsibility.

5.2 Module Boundaries  
Each module may ONLY contain logic related to its domain.  
Cross-domain calls must go through the DM4 namespace (e.g., DM4.state, DM4.map, DM4.editor, DM4.panels.registry).

5.3 Namespace Requirements  
All modules must attach to:

    window.DM4 = window.DM4 || {};

And must populate their sub-namespaces (DM4.state, DM4.map, DM4.editor, DM4.panels, DM4.ui) without redefining them.

5.4 Script Load Order (Mandatory)

In index.html and any equivalent host, modules must load in this order (or an explicitly agreed extension):

1. dm4-state.js
2. dm4-panels-editor.js
3. dm4-map-layers.js
4. dm4-panels-registry.js
5. dreadmarch-viewer4.js (thin core + host bootstrap)

Any deviation is a fatal error and must be fixed before continuing development.

5.5 Module Self-Tests (Future)  
Each module should expose a self-test under:

    DM4.selftest.<moduleName>()

Bootstrap may run module self-tests before enabling the UI. This is desirable but not required for every incremental refactor.

6. Change Management Rules
--------------------------

6.1 Every structural or behavioral change must be explainable in a short rationale.  
When asked, the AI must be able to state:  
- What changed  
- Why it changed  
- Which protocol sections allowed it.

6.2 Structural or architectural changes require a protocol version bump (this document).  
Minor CSS or text tweaks do not, unless they change contracts.

6.3 New features must be introduced behind explicit user approval.  
The AI may propose options, but must not enable them without user consent.

6.4 No Hidden Complexity  
If a change increases complexity (more files, more indirection, more state), the AI must either:
- Justify that complexity clearly, or
- Propose a simpler alternative per Rule 0.5.

7. Integrity Tracking
---------------------

7.1 All canonical files must appear in the integrity section once integrity tracking is formalized.  
7.2 Hashes must be updated only after a confirmed patch and user approval.  
7.3 Intermediate / experimental bundles should be clearly labeled as non-canonical.

8. Logging Standards
--------------------

8.1 All modules must use the centralized DM4.Logger utility for diagnostic messages.  
8.2 Direct console.* calls are prohibited outside of the Logger module itself.  
8.3 Logger provides four standardized methods:
    - DM4.Logger.log(message, ...args): General-purpose log messages
    - DM4.Logger.warn(message, ...args): Warnings about recoverable issues
    - DM4.Logger.error(message, ...args): Non-fatal errors requiring developer attention
    - DM4.Logger.critical(message, fallbackFn, ...args): Critical errors requiring fallback mechanisms

8.4 Critical Error Fallbacks  
When using Logger.critical(), a fallback function must be provided that:
- Returns a safe default value or empty structure
- Allows the application to continue running in a degraded state
- Never throws exceptions

8.5 Message Format  
Logger automatically prefixes all messages with "[DREADMARCH]". Module-specific prefixes 
should be included in the message itself (e.g., "[STATE]", "[EDITOR]", "[PANEL]").

8.6 Debug-Only Logging  
Logging calls may be conditionally guarded by DM4_DEBUG checks when appropriate, but 
critical errors and warnings should always be logged regardless of debug mode.

9. Integrity Hashes (Placeholder)
---------------------------------

This section will be populated once the integrity workflow is finalized for the modular viewer.  
For now, integrity is tracked informally via bundle names, protocol versions, and explicit user confirmation of canonical status.
